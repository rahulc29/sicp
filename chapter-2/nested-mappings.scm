#lang sicp
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= 0 (remainder b a)))
(define (square x)
  (* x x))
(define (smallest-divisor n)
  (find-divisor n 2))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (enumerate-interval start end)
  (if (> start end) 
      '() 
      (cons start (enumerate-interval (+ start 1) end))))
(define (accumulate op id seq)
  (if (null? seq)
      id
      (op (car seq) (accumulate op id (cdr seq)))))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define (enumerate-pair-intervals n)
  (flatmap (lambda (i) 
             (map (lambda (j) (list j i))
                  (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))
(define (prime-sum? pair)
  (prime? (+ (car pair)
             (car (cdr pair)))))
(define (filter pred seq)
  (accumulate (lambda (curr rest)
                (if (pred curr)
                    (cons curr rest)
                    rest))
              '()
              seq))
(define (make-pair-sum pair)
  (let ((first (car pair))
        (second (car (cdr pair))))
    (list first second (+ first second))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (enumerate-pair-intervals n))))
(define (remove x list)
  (filter (lambda (y)
            (not (= y x)))
          list))
(define (permutations set)
  (if (null? set) (list '())
      (flatmap (lambda (x)
                 (map (lambda (y) (cons x y))
                      (permutations
                       (remove x set))))
               set)))
